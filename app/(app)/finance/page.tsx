"use client";

import Link from "next/link";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Button } from "@/app/components/ui/Button";
import {
  type DbFinanceTx,
  listFinanceTx,
  createFinanceTx,
  upsertAutoFinanceTx,
  updateFinanceTx,
  deleteFinanceTx,
} from "@/src/lib/supabase/finance";
import {
  type DbBranch,
  listBranches,
} from "@/src/lib/supabase/branches";
import {
  type DbStaff,
  listStaff,
} from "@/src/lib/supabase/staff";
import {
  type DbPayment,
  listPayments,
} from "@/src/lib/supabase/payments";
import {
  listStaffAttendance,
  type DbStaffAttendance,
  countSessionsInMonth,
  ATTENDANCE_STATUS_LABELS,
} from "@/src/lib/supabase/staff-attendance";
import {
  listSessions,
  type DbSession,
} from "@/src/lib/supabase/sessions";
import {
  listPlayers,
  type DbPlayer,
} from "@/src/lib/supabase/players";

// ── Error helper ───────────────────────────────────────────────────────────────
function formatError(e: unknown): string {
  if (!e) return "خطأ غير محدد";
  if (e instanceof Error) return e.message;
  if (typeof e === "object") {
    const pg = e as Record<string, unknown>;
    const parts: string[] = [];
    if (pg.message) parts.push(`message: ${pg.message}`);
    if (pg.code)    parts.push(`code: ${pg.code}`);
    if (pg.details) parts.push(`details: ${pg.details}`);
    if (pg.hint)    parts.push(`hint: ${pg.hint}`);
    if (parts.length) return parts.join(" | ");
    return JSON.stringify(e);
  }
  return String(e);
}

// ── Types ──────────────────────────────────────────────────────────────────────
type TxType = "مصروف" | "إيراد";
// "suppressed" = auto entry deleted by user; persisted in DB with amount=0 so it
// won't be regenerated by the auto-sync. Filtered from all UI views.
type SourceType = "auto" | "manual" | "suppressed";
type Category =
  | "حجز ملعب"
  | "رواتب"
  | "اشتراكات"
  | "أدوات"
  | "تسويق"
  | "صيانة"
  | "مواصلات"
  | "أخرى";

type FinanceTx = {
  id: string;
  month: string;
  dateISO: string;
  type: TxType;
  branchId: string;
  category: Category;
  amount: number;
  note?: string;
  source: SourceType;
  autoKey?: string;
  overriddenAutoKey?: string;
  createdAtISO: string;
  updatedAtISO?: string;
};

type BranchLite = { id: string; name: string; rent_type: string; monthly_rent: number; days: string[] };
type StaffLite = {
  id: string;
  name: string;
  role: string;
  jobTitle?: string;
  monthlySalary: number;
  branchIds: string[];
  isActive: boolean;
};
type Payment = {
  id: string;
  dateISO: string;
  branchId: string | null;
  playerId: string;
  amount: number;
  kind: "new" | "renew" | "legacy";
};

type SortKey = "date_desc" | "date_asc" | "amount_desc" | "amount_asc";

type SubItem = {
  id: string;
  date?: string;
  label: string;
  amount: number; // negative = saving/deduction
};
type GroupedTxView = {
  tx: FinanceTx;
  subItems: SubItem[];
  grossAmount: number; // tx.amount + abs(sum of negative sub-items) — for expanded header
};

// ── DB → local mappers ─────────────────────────────────────────────────────────
function dbToTx(db: DbFinanceTx): FinanceTx {
  return {
    id: db.id,
    month: db.month,
    dateISO: db.date,
    type: db.type as TxType,
    branchId: db.branch_id,
    category: db.category as Category,
    amount: Number(db.amount),
    note: db.note ?? undefined,
    source: db.source as SourceType,
    autoKey: db.auto_key ?? undefined,
    overriddenAutoKey: db.overridden_auto_key ?? undefined,
    createdAtISO: db.created_at,
    updatedAtISO: db.updated_at ?? undefined,
  };
}

function dbToStaffLite(db: DbStaff): StaffLite {
  return {
    id: db.id,
    name: db.name,
    role: db.role,
    jobTitle: db.job_title ?? undefined,
    monthlySalary: Number(db.monthly_salary),
    branchIds: db.branch_ids ?? [],
    isActive: db.is_active,
  };
}

function dbToPayment(db: DbPayment): Payment {
  return {
    id: db.id,
    dateISO: db.date,
    branchId: db.branch_id,
    playerId: db.player_id,
    amount: Number(db.amount),
    kind: db.kind,
  };
}

// ── Helpers ────────────────────────────────────────────────────────────────────
function todayISO() { return new Date().toISOString().slice(0, 10); }
function monthKey(iso: string) { return iso.slice(0, 7); }
function money(n: number) {
  const v = Math.round((Number(n || 0) + Number.EPSILON) * 100) / 100;
  return `${v} د.ك`;
}
function pct(n: number) {
  if (!Number.isFinite(n)) return "0%";
  return `${Math.round(n * 10) / 10}%`;
}
function prevMonthKey(yyyyMM: string) {
  const [y, m] = yyyyMM.split("-").map(Number);
  return new Date(y, m - 2, 1).toISOString().slice(0, 7);
}

type PrintMode = "main_only" | "with_sub" | "revenues" | "expenses" | "all";

// ── Page ───────────────────────────────────────────────────────────────────────
export default function FinancePage() {
  const [branches, setBranches] = useState<BranchLite[]>([]);
  const [staff, setStaff] = useState<StaffLite[]>([]);
  const [tx, setTx] = useState<FinanceTx[]>([]);
  const [payments, setPayments] = useState<Payment[]>([]);
  const [staffAttendance, setStaffAttendance] = useState<DbStaffAttendance[]>([]);
  const [sessions,        setSessions]        = useState<DbSession[]>([]);
  const [players,         setPlayers]         = useState<{ id: string; name: string }[]>([]);
  const [expandedTxIds,   setExpandedTxIds]   = useState<Set<string>>(new Set());

  const [loading, setLoading] = useState(true);
  const [pageError, setPageError] = useState<string | null>(null);
  const [autoSyncing, setAutoSyncing] = useState(false);
  const [saving, setSaving] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);
  const [printOpen, setPrintOpen] = useState(false);

  // filters
  const [selectedBranch, setSelectedBranch] = useState<string>("all");
  const [selectedMonth, setSelectedMonth] = useState<string>(monthKey(todayISO()));

  // advanced filters
  const [q, setQ] = useState("");
  const [typeFilter, setTypeFilter] = useState<TxType | "all">("all");
  const [sourceFilter, setSourceFilter] = useState<"auto" | "manual" | "all">("all");
  const [sort, setSort] = useState<SortKey>("date_desc");

  // modal
  const [open, setOpen] = useState(false);
  const [editId, setEditId] = useState<string | null>(null);

  // form
  const [type, setType] = useState<TxType>("مصروف");
  const [branchId, setBranchId] = useState<string>("all");
  const [category, setCategory] = useState<Category>("أدوات");
  const [amount, setAmount] = useState<number>(0);
  const [dateISO, setDateISO] = useState<string>(todayISO());
  const [note, setNote] = useState<string>("");

  // Track last auto-sync key to avoid redundant runs
  const lastAutoSyncRef = useRef<string>("");
  // Always-current ref to tx — lets the auto-sync read latest tx without adding
  // tx to the dependency array (which would cause infinite re-run loops).
  const txRef = useRef<FinanceTx[]>([]);
  useEffect(() => { txRef.current = tx; }, [tx]);

  // ── Initial load ────────────────────────────────────────────────────────────
  const loadData = useCallback(async () => {
    setLoading(true);
    setPageError(null);
    try {
      const [dbBranches, dbStaff, dbTx, dbPayments, dbPlayers] = await Promise.all([
        listBranches(),
        listStaff(),
        listFinanceTx(),
        listPayments(),
        listPlayers(),
      ]);
      setBranches(
        dbBranches.map((b: DbBranch) => ({
          id: b.id,
          name: b.name,
          rent_type: b.rent_type,
          monthly_rent: Number(b.monthly_rent) || 0,
          days: b.days ?? [],
        }))
      );
      setStaff(dbStaff.map(dbToStaffLite));
      setTx(dbTx.map(dbToTx));
      setPayments(dbPayments.map(dbToPayment));
      setPlayers(dbPlayers.map((p: DbPlayer) => ({ id: p.id, name: p.name })));
    } catch (e) {
      console.error("[finance] load error:", e);
      setPageError(formatError(e));
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => { loadData(); }, [loadData]);

  // ── Staff attendance for selected month (used to compute net salary) ─────────
  useEffect(() => {
    let cancelled = false;
    listStaffAttendance(selectedMonth)
      .then((rows) => { if (!cancelled) setStaffAttendance(rows); })
      .catch(() => { if (!cancelled) setStaffAttendance([]); });
    return () => { cancelled = true; };
  }, [selectedMonth]);

  // ── Sessions for selected month (used to compute per_session rent) ───────────
  useEffect(() => {
    let cancelled = false;
    const [y, m] = selectedMonth.split("-").map(Number);
    const lastDay  = new Date(y, m, 0).getDate();
    const fromDate = `${selectedMonth}-01`;
    const toDate   = `${selectedMonth}-${String(lastDay).padStart(2, "0")}`;
    listSessions(fromDate, toDate)
      .then((rows) => { if (!cancelled) setSessions(rows); })
      .catch(() => { if (!cancelled) setSessions([]); });
    return () => { cancelled = true; };
  }, [selectedMonth]);

  // ── Payment amount helpers ──────────────────────────────────────────────────
  const playerPriceMap = useMemo(() => {
    const m = new Map<string, number>();
    for (const p of payments) {
      if (!m.has(p.playerId)) {
        const v = Number(p.amount);
        if (Number.isFinite(v) && v > 0) m.set(p.playerId, v);
      }
    }
    return m;
  }, [payments]);

  function effectivePaymentAmount(p: Payment): number {
    const pp = playerPriceMap.get(p.playerId);
    if (pp && Number.isFinite(pp) && pp > 0) return pp;
    return Number(p.amount) || 0;
  }

  const playerMap = useMemo(
    () => new Map(players.map((p) => [p.id, p.name])),
    [players]
  );

  // ── Auto-generation sync ────────────────────────────────────────────────────
  // Runs when selectedMonth, branches, staff, payments, tx, or loading changes.
  // Uses txRef.current for reading (always latest) to avoid stale closures.
  // Suppressed entries (source="suppressed") prevent regeneration of deleted auto entries.
  useEffect(() => {
    if (loading || !branches.length) return;

    // Compute suppressed auto_keys for the selected month from latest tx
    const suppressedInMonth = txRef.current
      .filter((t) => t.month === selectedMonth && t.source === "suppressed" && t.autoKey)
      .map((t) => t.autoKey!)
      .sort()
      .join(",");

    const rentSum = branches.map((b) => `${b.id}=${b.rent_type}:${b.monthly_rent}`).join(",");
    const deductionSummary = staffAttendance
      .filter((r) => r.deduct_from_salary && r.deduction_amount > 0)
      .map((r) => `${r.staff_id}:${r.branch_id}:${r.deduction_amount}`)
      .sort()
      .join(",");
    // Track cancelled sessions to re-sync per_session rent when cancellations change
    const sessionsSummary = sessions
      .filter((s) => s.status === "cancelled")
      .map((s) => `${s.branch_id}:${s.date}:${s.field_cost}`)
      .sort()
      .join(",");
    const syncKey = `${selectedMonth}:${branches.length}:${staff.length}:${payments.length}:${suppressedInMonth}:${rentSum}:${deductionSummary}:${sessionsSummary}`;
    if (syncKey === lastAutoSyncRef.current) return;

    let cancelled = false;

    const sync = async () => {
      setAutoSyncing(true);
      try {
        // Read latest tx via ref to avoid stale closures
        const currentTx = txRef.current;
        const monthExisting = currentTx.filter((t) => t.month === selectedMonth);

        // Build auto_key → tx map (includes suppressed entries)
        const existingByAutoKey = new Map<string, FinanceTx>(
          monthExisting
            .filter((t) => t.autoKey)
            .map((t) => [t.autoKey!, t])
        );
        // Track overridden keys (manual entries that replaced auto ones)
        const overriddenKeys = new Set(
          monthExisting
            .filter((t) => t.overriddenAutoKey)
            .map((t) => t.overriddenAutoKey!)
        );
        // Build suppressed set from DB state — no localStorage needed
        const suppressedKeys = new Set(
          monthExisting
            .filter((t) => t.source === "suppressed" && t.autoKey)
            .map((t) => t.autoKey!)
        );

        const upsertOps: Promise<DbFinanceTx>[] = [];
        const deleteIds: string[] = [];

        // ── Cleanup: remove legacy sa: deduction entries (old approach) ────
        for (const t of monthExisting) {
          if (t.autoKey?.startsWith("sa:") && t.source === "auto") {
            deleteIds.push(t.id);
          }
        }

        // ── Build deduction map: "staffId:branchId" → total deductions ─────
        // staffAttendance is loaded for selectedMonth via a separate useEffect.
        const deductionMap = new Map<string, number>();
        for (const row of staffAttendance) {
          if (!row.deduct_from_salary || row.deduction_amount <= 0) continue;
          const k = `${row.staff_id}:${row.branch_id}`;
          deductionMap.set(k, (deductionMap.get(k) ?? 0) + Number(row.deduction_amount));
        }

        // ── 1) Salaries per active staff member per branch ─────────────────
        // Net salary = base share − sum of attendance deductions for that branch.
        for (const m of staff.filter((x) => x.isActive)) {
          const ids = m.branchIds || [];
          if (!ids.length) continue;
          const share = Math.round(((m.monthlySalary || 0) / ids.length) * 100) / 100;
          if (!Number.isFinite(share) || share <= 0) continue;

          for (const bid of ids) {
            const autoKey = `salary:${selectedMonth}:${m.id}:${bid}`;
            if (suppressedKeys.has(autoKey)) continue;  // user deleted → skip
            if (overriddenKeys.has(autoKey)) continue;  // manual override exists

            const deductionForBranch = deductionMap.get(`${m.id}:${bid}`) ?? 0;
            const netShare = Math.max(0, Math.round((share - deductionForBranch) * 100) / 100);

            const bName = branches.find((b) => b.id === bid)?.name ?? "—";
            const baseNote = `${m.name} — ${m.role}${
              m.role === "موظف" && m.jobTitle ? ` (${m.jobTitle})` : ""
            } — ${bName}`;
            const noteText = deductionForBranch > 0
              ? `${baseNote} (خصومات: ${deductionForBranch} د.ك)`
              : baseNote;

            const existing = existingByAutoKey.get(autoKey);
            if (existing) {
              if (existing.source === "suppressed") continue;
              if (existing.amount !== netShare || existing.note !== noteText) {
                upsertOps.push(
                  upsertAutoFinanceTx({
                    month: selectedMonth,
                    date: `${selectedMonth}-01`,
                    type: "مصروف",
                    branch_id: bid,
                    category: "رواتب",
                    amount: netShare,
                    note: noteText,
                    source: "auto",
                    auto_key: autoKey,
                  })
                );
              }
            } else {
              upsertOps.push(
                upsertAutoFinanceTx({
                  month: selectedMonth,
                  date: `${selectedMonth}-01`,
                  type: "مصروف",
                  branch_id: bid,
                  category: "رواتب",
                  amount: netShare,
                  note: noteText,
                  source: "auto",
                  auto_key: autoKey,
                })
              );
            }
          }
        }

        // ── 2) Subscription revenue per branch ────────────────────────────
        const monthPayments = payments.filter(
          (p) => p.dateISO.slice(0, 7) === selectedMonth
        );

        for (const b of branches) {
          const autoKey = `rev:${selectedMonth}:${b.id}`;
          if (suppressedKeys.has(autoKey)) continue;  // user deleted → skip

          const list = monthPayments.filter((p) => p.branchId === b.id);
          const sum = list.reduce((s, p) => s + effectivePaymentAmount(p), 0);
          const newCount = list.filter((x) => x.kind === "new").length;
          const renewCount = list.filter((x) => x.kind === "renew").length;
          const noteText = `إيرادات اشتراكات اللاعبين — جديد: ${newCount} | تجديد: ${renewCount}`;

          const existing =
            existingByAutoKey.get(autoKey) ??
            monthExisting.find((t) => t.overriddenAutoKey === autoKey);

          if (!Number.isFinite(sum) || sum <= 0) {
            // Delete auto entry if it exists and is still "auto" (not suppressed/overridden)
            if (existing?.autoKey === autoKey && existing.source === "auto") {
              deleteIds.push(existing.id);
            }
            continue;
          }

          if (existing) {
            if (existing.source === "suppressed") continue;
            if (existing.amount !== sum || existing.note !== noteText) {
              if (existing.autoKey === autoKey || existing.overriddenAutoKey === autoKey) {
                upsertOps.push(
                  upsertAutoFinanceTx({
                    month: selectedMonth,
                    date: `${selectedMonth}-01`,
                    type: "إيراد",
                    branch_id: b.id,
                    category: "اشتراكات",
                    amount: Math.round(sum * 100) / 100,
                    note: noteText,
                    source: "auto",
                    auto_key: autoKey,
                  })
                );
              }
            }
          } else if (!overriddenKeys.has(autoKey)) {
            upsertOps.push(
              upsertAutoFinanceTx({
                month: selectedMonth,
                date: `${selectedMonth}-01`,
                type: "إيراد",
                branch_id: b.id,
                category: "اشتراكات",
                amount: Math.round(sum * 100) / 100,
                note: noteText,
                source: "auto",
                auto_key: autoKey,
              })
            );
          }
        }

        // ── 3) Field rent per branch (fixed_monthly + per_session) ───────────
        // auto_key: rent:{month}:{branchId} — one aggregate entry per branch.
        //
        // fixed_monthly → amount = monthly_rent (unchanged from before).
        // per_session   → amount = actual_sessions × per_session_cost
        //                 where:
        //   scheduled    = countSessionsInMonth(branch.days)
        //   per_session  = monthly_rent / scheduled
        //   actual       = scheduled – cancelled sessions (any field_cost)
        //                  Cancelled-with-field-cost sessions are tracked via
        //                  individual session-field:{branchId}:{date} entries
        //                  so they must be excluded from this aggregate to avoid
        //                  double-counting.
        const [rentYear, rentMonthNum] = selectedMonth.split("-").map(Number);

        for (const b of branches) {
          const autoKey    = `rent:${selectedMonth}:${b.id}`;
          const isFixed    = b.rent_type === "fixed_monthly";
          const isPerSess  = b.rent_type === "per_session";
          const rent       = b.monthly_rent;
          const existing   = existingByAutoKey.get(autoKey);

          // Unknown/unset rent type or no rent configured → remove any stale entry
          if ((!isFixed && !isPerSess) || rent <= 0) {
            if (existing?.autoKey === autoKey && existing.source === "auto") {
              deleteIds.push(existing.id);
            }
            continue;
          }

          if (suppressedKeys.has(autoKey)) continue;
          if (overriddenKeys.has(autoKey)) continue;

          let amount:   number;
          let noteText: string;

          if (isFixed) {
            amount   = rent;
            noteText = `إيجار ملعب شهري — ${b.name}`;
          } else {
            // per_session: monthly_rent IS the per-session cost.
            // total = actual_sessions × per_session_cost
            const scheduled = countSessionsInMonth(rentYear, rentMonthNum, b.days);
            if (scheduled <= 0) {
              // No sessions this month — remove entry
              if (existing?.autoKey === autoKey && existing.source === "auto") {
                deleteIds.push(existing.id);
              }
              continue;
            }
            // Count all cancelled sessions for this branch in this month.
            // Cancelled-with-field-cost sessions have their own session-field: entry,
            // so ALL cancelled sessions are excluded from the aggregate.
            const cancelledCount = sessions.filter(
              (s) =>
                s.branch_id === b.id &&
                s.date.slice(0, 7) === selectedMonth &&
                s.status === "cancelled"
            ).length;
            const actual = Math.max(0, scheduled - cancelledCount);
            amount       = Math.round(actual * rent * 100) / 100;
            noteText     = `إيجار ملعب بالحصة — ${b.name} (${actual}/${scheduled} حصص × ${rent} د.ك)`;
          }

          if (amount <= 0) {
            if (existing?.autoKey === autoKey && existing.source === "auto") {
              deleteIds.push(existing.id);
            }
            continue;
          }

          if (existing) {
            if (existing.source === "suppressed") continue;
            if (existing.amount !== amount || existing.note !== noteText) {
              upsertOps.push(
                upsertAutoFinanceTx({
                  month: selectedMonth,
                  date: `${selectedMonth}-01`,
                  type: "مصروف",
                  branch_id: b.id,
                  category: "حجز ملعب",
                  amount,
                  note: noteText,
                  source: "auto",
                  auto_key: autoKey,
                })
              );
            }
          } else {
            upsertOps.push(
              upsertAutoFinanceTx({
                month: selectedMonth,
                date: `${selectedMonth}-01`,
                type: "مصروف",
                branch_id: b.id,
                category: "حجز ملعب",
                amount,
                note: noteText,
                source: "auto",
                auto_key: autoKey,
              })
            );
          }
        }

        if (cancelled) return;

        const hasWork = upsertOps.length > 0 || deleteIds.length > 0;
        if (hasWork) {
          await Promise.all([
            ...upsertOps,
            ...deleteIds.map((id) => deleteFinanceTx(id)),
          ]);
          if (cancelled) return;
          const updated = await listFinanceTx();
          if (!cancelled) setTx(updated.map(dbToTx));
        }

        lastAutoSyncRef.current = syncKey;
      } catch (e) {
        console.error("[finance] auto-sync error:", e);
      } finally {
        if (!cancelled) setAutoSyncing(false);
      }
    };

    sync();
    return () => { cancelled = true; };
    // tx is intentionally excluded from deps (we use txRef.current instead to
    // avoid infinite loops while still reading the freshest value).
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedMonth, branches, staff, payments, staffAttendance, sessions, loading]);

  // ── Branch name helper ──────────────────────────────────────────────────────
  function branchName(id: string) {
    if (id === "all") return "عام (الأكاديمية)";
    return branches.find((b) => b.id === id)?.name ?? "—";
  }

  function toggleExpand(id: string) {
    setExpandedTxIds((prev) => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id); else next.add(id);
      return next;
    });
  }

  // ── Month view (suppressed entries are hidden from all UI) ──────────────────
  const monthTx = useMemo(
    () =>
      tx
        .filter((t) => t.source !== "suppressed")
        .filter((t) => t.month === selectedMonth)
        .filter((t) => {
          if (selectedBranch === "all") return true;
          return t.branchId === selectedBranch || t.branchId === "all";
        }),
    [tx, selectedMonth, selectedBranch]
  );

  // ── Advanced filter + sort ──────────────────────────────────────────────────
  const visibleTx = useMemo(() => {
    const query = q.trim().toLowerCase();
    let list = monthTx;
    if (typeFilter !== "all") list = list.filter((t) => t.type === typeFilter);
    if (sourceFilter !== "all") list = list.filter((t) => t.source === sourceFilter);
    if (query) {
      list = list.filter((t) => {
        const hay = [
          t.dateISO, t.type, t.category,
          branchName(t.branchId),
          String(t.amount),
          t.note || "",
          t.source === "auto" ? "تلقائي" : "يدوي",
        ]
          .join(" ")
          .toLowerCase();
        return hay.includes(query);
      });
    }
    return [...list].sort((a, b) => {
      if (sort === "date_desc")  return a.dateISO < b.dateISO ? 1 : -1;
      if (sort === "date_asc")   return a.dateISO > b.dateISO ? 1 : -1;
      if (sort === "amount_desc") return (b.amount || 0) - (a.amount || 0);
      if (sort === "amount_asc")  return (a.amount || 0) - (b.amount || 0);
      return 0;
    });
  }, [monthTx, q, typeFilter, sourceFilter, sort]); // eslint-disable-line react-hooks/exhaustive-deps

  // ── Grouped tx views (UI-only grouping — no DB changes) ────────────────────
  const groupedTxViews = useMemo((): GroupedTxView[] => {
    // Hide session-field: and sub_income: entries — they appear as sub-items under parent rows
    const mainTx = visibleTx.filter(
      (t) => !t.autoKey?.startsWith("session-field:") && !t.autoKey?.startsWith("sub_income:")
    );

    return mainTx.map((txItem): GroupedTxView => {
      const subItems: SubItem[] = [];

      // ── salary: → base + deduction sub-items + staff-substitute income sub-items ────
      if (txItem.autoKey?.startsWith("salary:")) {
        const parts      = txItem.autoKey.split(":");
        const staffId    = parts[2];
        const branchId   = parts[3];
        const staffMember = staff.find((s) => s.id === staffId);
        const branchCount = staffMember?.branchIds?.length || 1;
        const baseSalaryForBranch = staffMember
          ? Math.round(((staffMember.monthlySalary || 0) / branchCount) * 100) / 100
          : null;

        staffAttendance
          .filter((a) =>
            a.staff_id === staffId &&
            a.branch_id === branchId &&
            a.deduct_from_salary &&
            a.deduction_amount > 0
          )
          .forEach((a) => {
            const statusLabel = ATTENDANCE_STATUS_LABELS[a.status] ?? a.status;
            subItems.push({
              id: a.id,
              date: a.date,
              label: `خصم — ${statusLabel}`,
              amount: -a.deduction_amount,
            });
          });

        // sub_income: entries for this staff member in this month → positive sub-items
        monthTx
          .filter((t) => t.autoKey?.startsWith(`sub_income:${txItem.autoKey!.split(":")[1]}:${staffId}:`))
          .forEach((t) => {
            subItems.push({
              id: t.id,
              date: t.dateISO,
              label: t.note ?? "مكافأة حضور بديل",
              amount: t.amount,
            });
          });

        const totalAdditions  = subItems.filter((i) => i.amount > 0).reduce((s, i) => s + i.amount, 0);
        const grossAmount = txItem.amount + totalAdditions;
        // Prepend base salary sub-item so breakdown reads: base → deductions → substitute additions
        if (baseSalaryForBranch && baseSalaryForBranch > 0) {
          subItems.unshift({
            id: `base-${txItem.id}`,
            date: txItem.dateISO,
            label: "الراتب الأساسي",
            amount: baseSalaryForBranch,
          });
        }
        return { tx: txItem, subItems, grossAmount };
      }

      // ── rent: → cancelled session sub-items (per_session only) ─────────────
      if (txItem.autoKey?.startsWith("rent:")) {
        const branchId = txItem.autoKey.split(":")[2];
        const branch   = branches.find((b) => b.id === branchId);

        if (branch?.rent_type === "per_session" && branch.monthly_rent > 0) {
          const [y, m] = selectedMonth.split("-").map(Number);
          const scheduled = countSessionsInMonth(y, m, branch.days);
          const gross = Math.round(scheduled * branch.monthly_rent * 100) / 100;

          sessions
            .filter(
              (s) =>
                s.branch_id === branchId &&
                s.date.slice(0, 7) === selectedMonth &&
                s.status === "cancelled"
            )
            .forEach((s) => {
              // Show saving only if session-field entry has amount=0 (cost removed)
              const sfEntry = tx.find(
                (t2) => t2.autoKey === `session-field:${branchId}:${s.date}`
              );
              if (!sfEntry || sfEntry.amount === 0) {
                subItems.push({
                  id: `sf-${s.id}`,
                  date: s.date,
                  label: "حصة ملغاة — توفير تكلفة الملعب",
                  amount: -branch.monthly_rent,
                });
              }
            });

          return { tx: txItem, subItems, grossAmount: gross };
        }
        return { tx: txItem, subItems: [], grossAmount: txItem.amount };
      }

      // ── rev: → payment sub-items ────────────────────────────────────────────
      if (txItem.autoKey?.startsWith("rev:")) {
        const branchId = txItem.autoKey.split(":")[2];

        payments
          .filter(
            (p) =>
              p.branchId === branchId &&
              p.dateISO.slice(0, 7) === selectedMonth
          )
          .forEach((p) => {
            const playerName = playerMap.get(p.playerId) ?? "لاعب";
            const kindLabel  =
              p.kind === "new" ? "جديد" : p.kind === "renew" ? "تجديد" : "مستورد";
            subItems.push({
              id: p.id,
              date: p.dateISO,
              label: `${kindLabel} — ${playerName}`,
              amount: p.amount,
            });
          });

        return { tx: txItem, subItems, grossAmount: txItem.amount };
      }

      // Manual / other auto entries — no sub-items
      return { tx: txItem, subItems: [], grossAmount: txItem.amount };
    });
  }, [visibleTx, tx, staff, staffAttendance, branches, sessions, payments, playerMap, selectedMonth]); // eslint-disable-line react-hooks/exhaustive-deps

  // ── Summary KPIs ───────────────────────────────────────────────────────────
  const summary = useMemo(() => {
    const revenue  = monthTx.filter((t) => t.type === "إيراد").reduce((s, t) => s + t.amount, 0);
    const expenses = monthTx.filter((t) => t.type === "مصروف").reduce((s, t) => s + t.amount, 0);
    const profit   = revenue - expenses;
    const margin   = revenue > 0 ? (profit / revenue) * 100 : 0;
    const salaries = monthTx.filter((t) => t.type === "مصروف" && t.category === "رواتب").reduce((s, t) => s + t.amount, 0);
    const field    = monthTx.filter((t) => t.type === "مصروف" && t.category === "حجز ملعب").reduce((s, t) => s + t.amount, 0);
    return { revenue, expenses, profit, margin, salaries, field };
  }, [monthTx]);

  const subscriptionKPI = useMemo(() => {
    const list = payments
      .filter((p) => p.dateISO.slice(0, 7) === selectedMonth)
      .filter((p) => selectedBranch === "all" ? true : p.branchId === selectedBranch);
    const sum = list.reduce((s, p) => s + effectivePaymentAmount(p), 0);
    return {
      count: list.length,
      sum,
      avg: list.length ? sum / list.length : 0,
      newCount:   list.filter((x) => x.kind === "new").length,
      renewCount: list.filter((x) => x.kind === "renew").length,
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [payments, selectedMonth, selectedBranch, playerPriceMap]);

  const mom = useMemo(() => {
    const pm = prevMonthKey(selectedMonth);
    const prevMonthTx = tx
      .filter((t) => t.source !== "suppressed")
      .filter((t) => t.month === pm)
      .filter((t) => selectedBranch === "all" ? true : t.branchId === selectedBranch || t.branchId === "all");
    const prevRevenue  = prevMonthTx.filter((t) => t.type === "إيراد").reduce((s, t) => s + t.amount, 0);
    const prevExpenses = prevMonthTx.filter((t) => t.type === "مصروف").reduce((s, t) => s + t.amount, 0);
    return {
      prevMonth: pm,
      dRevenue:  summary.revenue  - prevRevenue,
      dExpenses: summary.expenses - prevExpenses,
      dProfit:   summary.profit   - (prevRevenue - prevExpenses),
    };
  }, [tx, selectedMonth, selectedBranch, summary]);

  // ── Modal helpers ───────────────────────────────────────────────────────────
  function resetForm() {
    setType("مصروف");
    setBranchId(selectedBranch === "all" ? "all" : selectedBranch);
    setCategory("أدوات");
    setAmount(0);
    setDateISO(`${selectedMonth}-01`);
    setNote("");
    setEditId(null);
    setSaveError(null);
  }

  function openAdd() {
    resetForm();
    setOpen(true);
  }

  function openEdit(item: FinanceTx) {
    setEditId(item.id);
    setType(item.type);
    setBranchId(item.branchId);
    setCategory(item.category);
    setAmount(item.amount);
    setDateISO(item.dateISO);
    setNote(item.note ?? "");
    setSaveError(null);
    setOpen(true);
  }

  function validateTx(): string | null {
    if (!dateISO) return "اختر التاريخ.";
    if (!Number.isFinite(amount) || amount <= 0) return "أدخل مبلغ صحيح.";
    if (!category) return "اختر التصنيف.";
    return null;
  }

  // ── Save tx ─────────────────────────────────────────────────────────────────
  async function saveTx() {
    const err = validateTx();
    if (err) { setSaveError(err); return; }

    setSaving(true);
    setSaveError(null);
    try {
      const month = monthKey(dateISO);

      if (editId) {
        const existing = tx.find((t) => t.id === editId);
        const becomesManual = existing?.source === "auto";

        const updated = await updateFinanceTx(editId, {
          month,
          date: dateISO,
          type,
          branch_id: branchId,
          category,
          amount: Number(amount),
          note: note.trim() || null,
          source: becomesManual ? "manual" : (existing?.source ?? "manual"),
          overridden_auto_key: becomesManual
            ? existing?.autoKey ?? null
            : existing?.overriddenAutoKey ?? null,
          auto_key: becomesManual ? null : existing?.autoKey ?? null,
        });

        setTx((prev) => prev.map((t) => (t.id === editId ? dbToTx(updated) : t)));
      } else {
        const created = await createFinanceTx({
          month,
          date: dateISO,
          type,
          branch_id: branchId,
          category,
          amount: Number(amount),
          note: note.trim() || null,
          source: "manual",
        });
        setTx((prev) => [dbToTx(created), ...prev]);
      }

      setOpen(false);
      resetForm();
    } catch (e) {
      console.error("[finance] save error:", e);
      setSaveError(formatError(e));
    } finally {
      setSaving(false);
    }
  }

  // ── Remove tx ───────────────────────────────────────────────────────────────
  // Auto entries: marked "suppressed" in DB (amount=0) instead of deleted.
  //   This prevents the auto-sync from regenerating them on next run.
  // Manual/other entries: deleted from DB normally.
  async function removeTx(item: FinanceTx) {
    if (!confirm("حذف هذا البند؟")) return;
    try {
      if (item.source === "auto" && item.autoKey) {
        // Suppress: keep row in DB but zero out and mark suppressed
        const updated = await updateFinanceTx(item.id, {
          source: "suppressed",
          amount: 0,
          note: null,
        });
        setTx((prev) => prev.map((x) => (x.id === item.id ? dbToTx(updated) : x)));
        // Clear ref so the auto-sync will re-evaluate on its next trigger
        lastAutoSyncRef.current = "";
      } else {
        await deleteFinanceTx(item.id);
        setTx((prev) => prev.filter((x) => x.id !== item.id));
      }
    } catch (e) {
      console.error("[finance] delete error:", e);
      alert(formatError(e));
    }
  }

  // ── Export CSV ──────────────────────────────────────────────────────────────
  function exportCSV() {
    const rows = visibleTx.map((t) => ({
      التاريخ: t.dateISO,
      الشهر: t.month,
      النوع: t.type,
      التصنيف: t.category,
      الفرع: branchName(t.branchId),
      المبلغ: t.amount,
      المصدر: t.source === "auto" ? "تلقائي" : "يدوي",
      الملاحظات: t.note ?? "",
    }));
    const headers = Object.keys(rows[0] || { التاريخ: "" });
    const csv =
      headers.join(",") +
      "\n" +
      rows
        .map((r) =>
          headers
            .map((h) => `"${String((r as Record<string, unknown>)[h] ?? "").replaceAll('"', '""')}"`)
            .join(",")
        )
        .join("\n");
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `finance_${selectedMonth}_${selectedBranch}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  // ── Print Finance ───────────────────────────────────────────────────────────
  function printFinance(mode: PrintMode) {
    const views = groupedTxViews.filter((v) => {
      if (mode === "revenues") return v.tx.type === "إيراد";
      if (mode === "expenses") return v.tx.type === "مصروف";
      return true;
    });

    const branchLabel = selectedBranch === "all"
      ? "جميع الفروع"
      : (branches.find((b) => b.id === selectedBranch)?.name ?? selectedBranch);
    const [y, m] = selectedMonth.split("-");
    const ARABIC_MONTHS = ["يناير","فبراير","مارس","أبريل","مايو","يونيو","يوليو","أغسطس","سبتمبر","أكتوبر","نوفمبر","ديسمبر"];
    const monthLabel = `${ARABIC_MONTHS[Number(m) - 1] ?? m} ${y}`;

    const totalRevenue = views.filter((v) => v.tx.type === "إيراد").reduce((s, v) => s + v.tx.amount, 0);
    const totalExpense = views.filter((v) => v.tx.type === "مصروف").reduce((s, v) => s + v.tx.amount, 0);
    const net = totalRevenue - totalExpense;

    const rowsHtml = views.map((v) => {
      const mainRow = `
        <tr>
          <td style="padding:6px 10px;border-bottom:1px solid #e5e7eb;font-weight:600;">${v.tx.note || v.tx.category}</td>
          <td style="padding:6px 10px;border-bottom:1px solid #e5e7eb;">${v.tx.type}</td>
          <td style="padding:6px 10px;border-bottom:1px solid #e5e7eb;">${v.tx.category}</td>
          <td style="padding:6px 10px;border-bottom:1px solid #e5e7eb;">${branchName(v.tx.branchId)}</td>
          <td style="padding:6px 10px;border-bottom:1px solid #e5e7eb;text-align:left;">${v.tx.dateISO}</td>
          <td style="padding:6px 10px;border-bottom:1px solid #e5e7eb;text-align:left;font-weight:600;color:${v.tx.type === "إيراد" ? "#16a34a" : "#dc2626"};">${v.tx.amount.toLocaleString("ar-KW")} د.ك</td>
        </tr>`;

      const subRows = (mode === "with_sub" || mode === "all") && v.subItems.length > 0
        ? v.subItems.map((s) => `
          <tr style="background:#f9fafb;">
            <td style="padding:4px 10px 4px 24px;border-bottom:1px solid #f3f4f6;font-size:12px;color:#6b7280;" colspan="3">↳ ${s.label}</td>
            <td style="padding:4px 10px;border-bottom:1px solid #f3f4f6;font-size:12px;color:#6b7280;">${s.date ?? ""}</td>
            <td></td>
            <td style="padding:4px 10px;border-bottom:1px solid #f3f4f6;font-size:12px;text-align:left;color:${s.amount < 0 ? "#dc2626" : "#16a34a"};">${s.amount > 0 ? "+" : ""}${s.amount.toLocaleString("ar-KW")} د.ك</td>
          </tr>`).join("")
        : "";

      return mainRow + subRows;
    }).join("");

    const html = `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
  <meta charset="UTF-8"/>
  <title>الإدارة المالية — ${monthLabel}</title>
  <style>
    body { font-family: 'Segoe UI', Arial, sans-serif; color: #111; margin: 0; padding: 24px; direction: rtl; }
    h1 { font-size: 20px; margin-bottom: 4px; }
    .subtitle { font-size: 13px; color: #555; margin-bottom: 20px; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    thead tr { background: #1e293b; color: #fff; }
    thead th { padding: 8px 10px; text-align: right; }
    thead th:last-child { text-align: left; }
    tbody tr:hover { background: #f8fafc; }
    .summary { margin-top: 20px; display: flex; gap: 32px; font-size: 14px; }
    .summary span { font-weight: 600; }
    .green { color: #16a34a; } .red { color: #dc2626; } .blue { color: #1d4ed8; }
    @media print { body { padding: 0; } }
  </style>
</head>
<body>
  <h1>الإدارة المالية</h1>
  <div class="subtitle">${monthLabel} · ${branchLabel}</div>
  <table>
    <thead>
      <tr>
        <th>البند</th><th>النوع</th><th>التصنيف</th><th>الفرع</th><th style="text-align:left;">التاريخ</th><th style="text-align:left;">المبلغ</th>
      </tr>
    </thead>
    <tbody>${rowsHtml}</tbody>
  </table>
  <div class="summary">
    <div>إجمالي الإيرادات: <span class="green">${totalRevenue.toLocaleString("ar-KW")} د.ك</span></div>
    <div>إجمالي المصروفات: <span class="red">${totalExpense.toLocaleString("ar-KW")} د.ك</span></div>
    <div>صافي الربح: <span class="${net >= 0 ? "green" : "red"}">${net.toLocaleString("ar-KW")} د.ك</span></div>
  </div>
</body>
</html>`;

    const w = window.open("", "_blank");
    if (!w) return;
    w.document.write(html);
    w.document.close();
    w.focus();
    setTimeout(() => { w.print(); }, 300);
    setPrintOpen(false);
  }

  // ── UI ──────────────────────────────────────────────────────────────────────
  return (
    <main className="flex-1 p-4 md:p-8">
        {/* Header */}
        <div className="flex items-center justify-between mb-6 gap-3 flex-wrap">
          <div>
            <h1 className="text-2xl font-semibold">الإدارة المالية</h1>
            <p className="text-sm text-white/60 mt-1">
              ملخصات ذكية + مقارنة شهرية + فلاتر متقدمة.
              {autoSyncing && (
                <span className="mr-2 text-emerald-400/80 text-xs">
                  جاري مزامنة البنود التلقائية...
                </span>
              )}
            </p>
          </div>

          <div className="flex items-center gap-2 flex-wrap" style={{ direction: "ltr" }}>
            <Link
              href="/finance/reports"
              className="h-9 px-4 rounded-xl bg-white/10 hover:bg-white/15 transition text-sm font-semibold inline-flex items-center"
            >
              التقارير
            </Link>
            <Button variant="secondary" onClick={() => setPrintOpen(true)} disabled={loading}>
              طباعة
            </Button>
            <Button variant="secondary" onClick={exportCSV} disabled={loading}>
              CSV
            </Button>
            <Button onClick={openAdd} disabled={loading}>
              + إضافة بند
            </Button>
          </div>
        </div>

        {/* Page error */}
        {pageError && (
          <div className="mb-4 rounded-xl border border-red-500/30 bg-red-500/10 px-4 py-3 text-sm text-red-300">
            {pageError}
            <button onClick={loadData} className="mr-3 underline" type="button">
              إعادة المحاولة
            </button>
          </div>
        )}

        {loading && (
          <div className="text-white/60 text-sm mb-4">جاري التحميل...</div>
        )}

        {/* Filters + Summary */}
        <div className="bg-[#111827] rounded-2xl p-4 space-y-4 border border-white/5">
          <div className="flex items-end gap-4 flex-wrap">
            {/* Branch selector */}
            <div className="min-w-[280px]">
              <label className="block text-xs text-white/60 mb-2">عرض البيانات لـ</label>
              <select
                value={selectedBranch}
                onChange={(e) => setSelectedBranch(e.target.value)}
                className="w-full h-11 rounded-xl bg-[#0F172A] border border-white/10 px-4 text-white outline-none focus:border-white/25"
              >
                <option value="all">جميع الفروع (نتائج الأكاديمية)</option>
                {branches.map((b) => (
                  <option key={b.id} value={b.id}>{b.name}</option>
                ))}
              </select>
            </div>

            {/* Month */}
            <div className="min-w-[200px]">
              <label className="block text-xs text-white/60 mb-2">الشهر</label>
              <input
                type="month"
                value={selectedMonth}
                onChange={(e) => {
                  lastAutoSyncRef.current = "";
                  setSelectedMonth(e.target.value);
                }}
                className="w-full h-11 rounded-xl bg-[#0F172A] border border-white/10 px-4 text-white outline-none focus:border-white/25"
              />
            </div>

            {/* Search */}
            <div className="flex-1 min-w-[260px]">
              <label className="block text-xs text-white/60 mb-2">بحث</label>
              <input
                value={q}
                onChange={(e) => setQ(e.target.value)}
                className="w-full h-11 rounded-xl bg-[#0F172A] border border-white/10 px-4 text-white outline-none focus:border-white/25"
                placeholder="ابحث في التصنيف/الملاحظات/المبلغ/الفرع..."
              />
            </div>

            {/* Type filter */}
            <div className="min-w-[160px]">
              <label className="block text-xs text-white/60 mb-2">النوع</label>
              <select
                value={typeFilter}
                onChange={(e) => setTypeFilter(e.target.value as TxType | "all")}
                className="w-full h-11 rounded-xl bg-[#0F172A] border border-white/10 px-4 text-white outline-none focus:border-white/25"
              >
                <option value="all">الكل</option>
                <option value="مصروف">مصروف</option>
                <option value="إيراد">إيراد</option>
              </select>
            </div>

            {/* Source filter */}
            <div className="min-w-[160px]">
              <label className="block text-xs text-white/60 mb-2">المصدر</label>
              <select
                value={sourceFilter}
                onChange={(e) => setSourceFilter(e.target.value as "auto" | "manual" | "all")}
                className="w-full h-11 rounded-xl bg-[#0F172A] border border-white/10 px-4 text-white outline-none focus:border-white/25"
              >
                <option value="all">الكل</option>
                <option value="auto">تلقائي</option>
                <option value="manual">يدوي</option>
              </select>
            </div>

            {/* Sort */}
            <div className="min-w-[180px]">
              <label className="block text-xs text-white/60 mb-2">الترتيب</label>
              <select
                value={sort}
                onChange={(e) => setSort(e.target.value as SortKey)}
                className="w-full h-11 rounded-xl bg-[#0F172A] border border-white/10 px-4 text-white outline-none focus:border-white/25"
              >
                <option value="date_desc">الأحدث أولاً</option>
                <option value="date_asc">الأقدم أولاً</option>
                <option value="amount_desc">الأعلى مبلغاً</option>
                <option value="amount_asc">الأقل مبلغاً</option>
              </select>
            </div>

            <div className="text-xs text-white/50">
              * إيرادات الاشتراكات تُحدَّث تلقائياً عند تغيّر الدفعات.
            </div>
          </div>

          {/* KPI cards */}
          <div className="grid grid-cols-1 md:grid-cols-4 gap-3">
            <Card title="الإيرادات" value={money(summary.revenue)} />
            <Card title="المصاريف" value={money(summary.expenses)} />
            <Card title="صافي الربح" value={money(summary.profit)} emphasize={summary.profit >= 0 ? "good" : "bad"} />
            <Card title="هامش الربح" value={pct(summary.margin)} />
          </div>

          <div className="grid grid-cols-1 md:grid-cols-4 gap-3">
            <Card title="الرواتب" value={money(summary.salaries)} />
            <Card title="حجز الملعب" value={money(summary.field)} />
            <Card title="عمليات الدفع" value={`${subscriptionKPI.count} عملية`} />
            <Card title="متوسط الدفع" value={money(subscriptionKPI.avg)} />
          </div>

          {/* MoM */}
          <div className="rounded-2xl bg-white/5 border border-white/10 p-4">
            <div className="text-xs text-white/60 mb-2">
              مقارنة مع الشهر السابق ({mom.prevMonth})
            </div>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
              <DeltaCard title="فرق الإيراد" value={mom.dRevenue} />
              <DeltaCard title="فرق المصروف" value={mom.dExpenses} inverse />
              <DeltaCard title="فرق الربح" value={mom.dProfit} />
            </div>
          </div>
        </div>

        {/* Table */}
        <div className="mt-6 bg-[#111827] rounded-2xl border border-white/5">
          <div className="overflow-x-auto">
          <div className="min-w-[860px]">
          <div className="bg-[#0F172A] px-6 py-4 text-sm text-white/80 grid grid-cols-[0.9fr_1fr_1.1fr_1fr_1fr_2fr_1.2fr] gap-4">
            <div>التاريخ</div>
            <div>النوع</div>
            <div>التصنيف</div>
            <div>الفرع</div>
            <div>المبلغ</div>
            <div>ملاحظات</div>
            <div className="text-right">الإجراء</div>
          </div>

          <div>
            {loading ? (
              <div className="px-6 py-8 text-white/60 text-sm">جاري التحميل...</div>
            ) : groupedTxViews.length === 0 ? (
              <div className="px-6 py-8 text-white/60 text-sm">
                لا توجد بنود لهذا الشهر/الفلتر.
              </div>
            ) : (
              groupedTxViews.map(({ tx: t, subItems, grossAmount }, idx) => {
                const zebra      = idx % 2 === 0 ? "bg-[#0B1220]" : "bg-[#0E1A2B]";
                const isExpense  = t.type === "مصروف";
                const isExpanded = expandedTxIds.has(t.id);
                const hasDetails = subItems.length > 0;

                return (
                  <div key={t.id}>
                    {/* Main row */}
                    <div className={`${zebra} px-6 py-4 grid grid-cols-[0.9fr_1fr_1.1fr_1fr_1fr_2fr_1.2fr] gap-4 items-center`}>
                      {/* Date + chevron */}
                      <div className="text-white/80 flex items-center gap-1.5">
                        <button
                          type="button"
                          onClick={() => hasDetails && toggleExpand(t.id)}
                          className={`w-4 h-4 text-[10px] flex items-center justify-center rounded transition shrink-0 ${
                            hasDetails
                              ? "text-white/50 hover:text-white/80 cursor-pointer"
                              : "text-transparent cursor-default pointer-events-none"
                          }`}
                          aria-label={isExpanded ? "طي" : "توسيع"}
                        >
                          {isExpanded ? "▲" : "▼"}
                        </button>
                        {t.dateISO}
                      </div>
                      {/* Type */}
                      <div>
                        <span className={isExpense
                          ? "inline-flex px-3 py-1 rounded-full text-xs bg-red-500/15 text-red-300"
                          : "inline-flex px-3 py-1 rounded-full text-xs bg-emerald-500/15 text-emerald-300"
                        }>{t.type}</span>
                        {t.source === "auto" && (
                          <span className="mr-2 inline-flex px-2 py-1 rounded-full text-[10px] bg-white/10 text-white/70">تلقائي</span>
                        )}
                      </div>
                      {/* Category */}
                      <div className="text-white/80">{t.category}</div>
                      {/* Branch */}
                      <div className="text-white/80">{branchName(t.branchId)}</div>
                      {/* Amount: TOTAL (including sub-items) when has sub-items */}
                      <div className="text-white/80">
                        {hasDetails ? money(grossAmount) : money(t.amount)}
                        {hasDetails && !isExpanded && (
                          <div className="text-[10px] text-white/40 mt-0.5">{subItems.length} بند</div>
                        )}
                      </div>
                      {/* Note */}
                      <div className="text-white/60">{t.note || "—"}</div>
                      {/* Actions */}
                      <div className="flex items-center justify-end gap-2" style={{ direction: "ltr" }}>
                        <Button variant="ghost" size="xs" onClick={() => openEdit(t)}>تعديل</Button>
                        <Button variant="danger" size="xs" onClick={() => removeTx(t)}>حذف</Button>
                      </div>
                    </div>

                    {/* Sub-item rows (only when expanded) */}
                    {isExpanded && subItems.map((sub) => (
                      <div
                        key={sub.id}
                        className="bg-[#080F1A] px-6 py-2 grid grid-cols-[0.9fr_1fr_1.1fr_1fr_1fr_2fr_1.2fr] gap-4 items-center border-t border-white/[0.04]"
                      >
                        <div className="text-white/40 text-xs pr-5">{sub.date || ""}</div>
                        <div></div>
                        <div className="text-white/40 text-xs">تفصيل</div>
                        <div></div>
                        <div className={`text-xs font-semibold ${sub.amount < 0 ? "text-red-400" : "text-emerald-400"}`}>
                          {sub.amount < 0 ? `−${money(Math.abs(sub.amount))}` : `+${money(sub.amount)}`}
                        </div>
                        <div className="text-white/50 text-xs">{sub.label}</div>
                        <div></div>
                      </div>
                    ))}

                    {/* Net summary row (only when expanded and has sub-items) */}
                    {isExpanded && hasDetails && (
                      <div className="bg-[#080F1A] px-6 py-2 grid grid-cols-[0.9fr_1fr_1.1fr_1fr_1fr_2fr_1.2fr] gap-4 items-center border-t border-white/10">
                        <div></div>
                        <div></div>
                        <div></div>
                        <div className="text-white/50 text-xs font-semibold">الإجمالي</div>
                        <div className="text-white/90 text-sm font-semibold">{money(grossAmount)}</div>
                        <div></div>
                        <div></div>
                      </div>
                    )}
                  </div>
                );
              })
            )}
          </div>
          </div>{/* min-w */}
          </div>{/* overflow-x-auto */}
        </div>

        {/* Modal */}
        {open && (
          <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 p-4">
            <div className="w-full max-w-[760px] rounded-[28px] bg-[#111827] border border-white/10 shadow-2xl max-h-[92vh] overflow-y-auto">
              <div className="px-4 sm:px-8 pt-6 sm:pt-8 flex items-start justify-between">
                <div>
                  <h2 className="text-3xl font-semibold">
                    {editId ? "تعديل بند" : "إضافة بند"}
                  </h2>
                  <p className="mt-2 text-white/60 text-sm">
                    يمكنك إضافة بنود يدوية أو تعديل بنود تلقائية.
                  </p>
                </div>
                <button
                  onClick={() => setOpen(false)}
                  className="h-10 w-10 rounded-xl bg-white/5 hover:bg-white/10 transition text-xl leading-none"
                  aria-label="إغلاق"
                >
                  ×
                </button>
              </div>

              <div className="px-8 py-6 space-y-4">
                {saveError && (
                  <div className="rounded-xl border border-red-500/30 bg-red-500/10 px-4 py-2 text-sm text-red-300">
                    {saveError}
                  </div>
                )}

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm text-white/70 mb-2">النوع</label>
                    <select
                      value={type}
                      onChange={(e) => setType(e.target.value as TxType)}
                      className="w-full h-11 rounded-xl bg-[#0F172A] border border-white/10 px-4 text-white outline-none focus:border-white/25"
                    >
                      <option value="مصروف">مصروف</option>
                      <option value="إيراد">إيراد</option>
                    </select>
                  </div>

                  <div>
                    <label className="block text-sm text-white/70 mb-2">التاريخ</label>
                    <input
                      type="date"
                      value={dateISO}
                      onChange={(e) => setDateISO(e.target.value)}
                      className="w-full h-11 rounded-xl bg-[#0F172A] border border-white/10 px-4 text-white outline-none focus:border-white/25"
                    />
                  </div>

                  <div>
                    <label className="block text-sm text-white/70 mb-2">الفرع</label>
                    <select
                      value={branchId}
                      onChange={(e) => setBranchId(e.target.value)}
                      className="w-full h-11 rounded-xl bg-[#0F172A] border border-white/10 px-4 text-white outline-none focus:border-white/25"
                    >
                      <option value="all">عام (الأكاديمية)</option>
                      {branches.map((b) => (
                        <option key={b.id} value={b.id}>{b.name}</option>
                      ))}
                    </select>
                  </div>

                  <div>
                    <label className="block text-sm text-white/70 mb-2">التصنيف</label>
                    <select
                      value={category}
                      onChange={(e) => setCategory(e.target.value as Category)}
                      className="w-full h-11 rounded-xl bg-[#0F172A] border border-white/10 px-4 text-white outline-none focus:border-white/25"
                    >
                      {(["اشتراكات", "حجز ملعب", "رواتب", "أدوات", "تسويق", "صيانة", "مواصلات", "أخرى"] as Category[]).map(
                        (c) => <option key={c} value={c}>{c}</option>
                      )}
                    </select>
                  </div>

                  <div className="md:col-span-2">
                    <label className="block text-sm text-white/70 mb-2">المبلغ (د.ك)</label>
                    <input
                      type="text"
                      inputMode="numeric"
                      value={amount === 0 ? "" : String(amount)}
                      onChange={(e) => {
                        const v = e.target.value.replace(/[^0-9]/g, "");
                        setAmount(v ? Number(v) : 0);
                      }}
                      className="w-full h-11 rounded-xl bg-[#0F172A] border border-white/10 px-4 text-white outline-none focus:border-white/25"
                      placeholder="مثال: 360"
                    />
                  </div>

                  <div className="md:col-span-2">
                    <label className="block text-sm text-white/70 mb-2">ملاحظات</label>
                    <textarea
                      value={note}
                      onChange={(e) => setNote(e.target.value)}
                      className="w-full min-h-[90px] rounded-xl bg-[#0F172A] border border-white/10 px-4 py-3 text-white outline-none focus:border-white/25"
                      placeholder="مثال: خصم على الملعب هذا الشهر..."
                    />
                  </div>
                </div>
              </div>

              <div className="px-8 pb-8 flex items-center justify-start gap-3">
                <Button variant="secondary" onClick={() => setOpen(false)}>
                  إلغاء
                </Button>
                <Button onClick={saveTx} disabled={saving}>
                  {saving ? "جاري الحفظ..." : editId ? "حفظ التعديل" : "إضافة"}
                </Button>
              </div>
            </div>
          </div>
        )}

        {/* Print dialog */}
        {printOpen && (
          <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 p-4">
            <div className="w-full max-w-sm rounded-[24px] bg-[#111827] border border-white/10 shadow-2xl p-6">
              <div className="flex items-center justify-between mb-5">
                <h2 className="text-xl font-semibold">خيارات الطباعة</h2>
                <button
                  onClick={() => setPrintOpen(false)}
                  className="h-9 w-9 rounded-xl bg-white/5 hover:bg-white/10 transition text-xl leading-none"
                  aria-label="إغلاق"
                >
                  ×
                </button>
              </div>
              <p className="text-sm text-white/50 mb-4">
                سيتم طباعة البنود المرشّحة حالياً ({groupedTxViews.length} بند).
              </p>
              <div className="space-y-2">
                {([
                  { mode: "main_only",  label: "أ — البنود الرئيسية فقط" },
                  { mode: "with_sub",   label: "ب — البنود الرئيسية مع التفاصيل" },
                  { mode: "revenues",   label: "ج — الإيرادات فقط" },
                  { mode: "expenses",   label: "د — المصروفات فقط" },
                  { mode: "all",        label: "هـ — الكل مع التفاصيل" },
                ] as { mode: "main_only" | "with_sub" | "revenues" | "expenses" | "all"; label: string }[]).map(({ mode, label }) => (
                  <button
                    key={mode}
                    type="button"
                    onClick={() => printFinance(mode)}
                    className="w-full text-right h-11 px-4 rounded-xl bg-white/5 hover:bg-[#63C0B0]/15 hover:text-[#63C0B0] transition text-sm font-medium border border-white/10"
                  >
                    {label}
                  </button>
                ))}
              </div>
            </div>
          </div>
        )}
      </main>
  );
}

// ── Sub-components ─────────────────────────────────────────────────────────────

function Card({
  title,
  value,
  emphasize,
}: {
  title: string;
  value: string;
  emphasize?: "good" | "bad";
}) {
  const cls =
    emphasize === "good" ? "text-emerald-300" :
    emphasize === "bad"  ? "text-red-300"     : "text-white";
  return (
    <div className="rounded-2xl bg-white/5 border border-white/10 p-4">
      <div className="text-xs text-white/60">{title}</div>
      <div className={`text-lg font-bold mt-1 ${cls}`}>{value}</div>
    </div>
  );
}

function DeltaCard({ title, value, inverse }: { title: string; value: number; inverse?: boolean }) {
  const positive = value >= 0;
  const good = inverse ? !positive : positive;
  const cls = good ? "text-emerald-300" : "text-red-300";
  return (
    <div className="rounded-2xl bg-[#0B1220] border border-white/10 p-4">
      <div className="text-xs text-white/60">{title}</div>
      <div className={`text-lg font-bold mt-1 ${cls}`}>
        {value >= 0 ? "+" : "-"}
        {money(Math.abs(value))}
      </div>
    </div>
  );
}
